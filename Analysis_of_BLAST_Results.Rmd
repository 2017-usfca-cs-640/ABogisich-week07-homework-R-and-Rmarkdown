---
title: "Analysis of BLAST Results"
author: "Allison Bogisich"
date: "October 16, 2017"
output: github_document
---

# Introduction

Only within the past decade or so has the technical capability to sequence complex biological samples  been able to take off to such an astounding extent. Recent developments in phylogenetic community analysis (Lozupune and Knight,2005) with high-throughput pyrosequencing methods (Hamandy et al.,2008) have established the criteria for not only sequencing microbiome samples, but the very foundations of bacterial forensics. Fierer and his team have conducted a series of studies that demonstrate the strengths and weaknesses of the field (Fierer et al., 2010). They found that skin-associated bacterial communities are surprisingly diverse, and that they are independently stable enough to assist traditional forensic evaluations.

Conventional methods of obtaining forensic results from human DNA require suffient amounts of blood, tissue, semen, or saliva on an object. However, it is often difficult to obtain a large (and uncontaminated) enough sample to sequence. In order to boost standard results, recovering bacterial DNA from touched surfaces may be far easier, espeically for identifying objects where clear fingerprints can't be obtained (e.g. fabrics, smudged surfaces, highly textured surfaces) (Ibid.) Given how abundant bacterial cells are on the surface of skin and on shed epidermal cells (Fredricks, 2001) and how highly personalized bacterial communities are implicates that more research is needed. In this post-analysis of Fierer's research, I compare the general makeup of the communities his team found on male versus female subjects.



# Methods

This post-experimental review is based on .csv output files from a BLAST search conducted from trimmed and quality checked fasta files from the Fierer team study. The BLAST search matched his swabbed and sequenced samples against the GenBank database from NCBI Sequence Read Archive study number ERP022657. The above process and the resulting files can be found in a Github repository 2017-usfca-cs-640/ABogisich-week06-homework-QC-and-BLAST. Using bioinformatic applications in R and R Studio, the samples were reorganized into easily readable histograms to compare the array of microbacterial fanua present on female and male subjects.

## Sample origin and sequencing

Fierer and his team swabbed for skin-associated bacteria from different epidermal regions for each of their three studies. For the keyboard study, three participants were swabbed on the ventral surface of the distal joint of each fingertip. All individuals were healthy 20-35 year olds that had not taken antibiotics at least six months prior to swabbing. In the "storage" study, autoclaved cotton-tipped swabs moistened with sterile solution were again used, this time to sample the right axilary (armpit) skin surface sixteen times, from two healthy adults. Lastly, in the computer mouse study nine healthy adults were recruited (four female and five male, all 20-35 years of age) who worked in the same University of Colorado building. Using the swabbing technique outlined above, the entirety of the exposed surface of their dominant hand's palm (used to control the computer mice) were awabbed. Palm surfaces were sampled at midday and the particpants had been following typical hand hygiene practices prior to sampling. Swabs were stored at -80 degrees before DNA extraction. The microbial communities on these participants were compared to a previously compiled database from 270 other hands sampled by Fierer and collaborators (Fierer et al., 2008; Costello et al., 2009). The 270 hands in the database were from left and right palm surfaces belonging to an equal proportion of both healthy male and female volunteers, aged 18-40 years old.

Post DNA extraction from the samples, sequences were processed and analyzed using pyrosequencing procedures akin to Fierer's work in 2008. Sequences were removed if shorter than 200 bp or larger than 300 in length, had a quality score lower than 25, had ambiguous characters or uncorrectable barcodes, or if it did not contain the primer sequence. Remaining sequences were assigned to samples via examination of the 12-nt barcode and then clustered into operational taxonomic units (OTUs). Representative sequences were selected for each OTU based on the longest length sequnce with the greast number of hits to other sequences within the OTU.

## Computational

The program R version 3.4.2 in conjunction with R Studio version 1.1.383 interface for Windows desktop was used. In addition, several packages listed below from the R library which were downloaded in order to utilize more specific exploratory data analysis functions. The blast data set and its associated metadata were joined together for use within a single dataframe. First, output files from BLAST sequence search results in .csv format were then read into proper dataframes using subsequent data qualifiers to parse query sequence identifiers into appropriately labeled columns/reading frames. The empty matrix for the joined data was then created, with a function that would loop and append together all the results for each of the BLAST results. Then the tab delimited metadata was read in and joined with the BLAST output using dpyler, forming one large data table for manipulation. Finally, in order to produce visible data based histograms, the diplyr piping system was used to select a subset of rows matching certain criterion and then pull out columns. 



# Results

```{r load-libraries, message = FALSE}
# Be sure to install these packages before running this script
# They can be installed either with the intall.packages() function
# or with the 'Packages' pane in RStudio

# load packages
library("dplyr")
library("tidyr")
library("knitr")
```

```{r make-read-in-data-function}
# Output format from BLAST is as detailed on:
# https://www.ncbi.nlm.nih.gov/books/NBK279675/
# In this case, we used: '10 sscinames std'
# 10 means csv format
# sscinames means unique Subject Scientific Name(s), separated by a ';'
# std means the standard set of result columns, which are:
# 'qseqid sseqid pident length mismatch
# gapopen qstart qend sstart send evalue bitscore',


# this function takes as input a quoted path to a BLAST result file
# and produces as output a dataframe with proper column headers
# and the 'qseqid' column split into sample and seq number
read_blast_output <- function(filename) {
  data_in <- read.csv(filename,
                      header = FALSE, # files don't have column names in them
                      col.names = c("sscinames", # unique Subject Sci Name(s)
                                    "qseqid",    # Query Seq-id
                                    "sseqid",    # Subject Seq-id
                                    "pident",    # Percntge of identical matches
                                    "length",    # Alignment length
                                    "mismatch",  # Number of mismatches
                                    "gapopen",   # Number of gap openings
                                    "qstart",    # Start of alignment in query
                                    "qend",      # End of alignment in query
                                    "sstart",    # Start of alignment in subj
                                    "send",      # End of alignment in subject
                                    "evalue",    # Expect value
                                    "bitscore"))  # Bit score

  # Next we want to split the query sequence ID into
  # Sample and Number components so we can group by sample
  # They originally look like "ERR1942280.1"
  # and we want to split that into two columns: "ERR1942280" and "1"
  # we can use the separate() function from the tidyr library to do this
  # Note that we have to double escape the period for this to work
  # the syntax is
  # separate(column_to_separate,
  # c("New_column_name_1", "New_column_name_2"),
  # "seperator")
  data_in <- data_in %>%
    separate(qseqid, c("sample_name", "sample_number"), "\\.")
}
```

```{r read-in-BLAST-data}
# this makes a vector of all the BLAST output file names, including
# the name(s) of the directories they are in
files_to_read_in <- list.files(path = "output/blast",
                               full.names = TRUE)

# We need to create an empty matrix with the right number of columns
# so that we can rbind() each dataset on to it
joined_blast_data <- matrix(nrow = 0,
                            ncol = 14)

# now we loop over each of the files in the list and append them
# to the bottom of the 'joined_blast_data' object
# we do this with the rbind() function and the function we
# made earlier to read in the files, read_blast_output()
for (filename in files_to_read_in) {
  joined_blast_data <- rbind(joined_blast_data,
                             read_blast_output(filename))
}
```

```{r read-in-metadata-and-join}
# Next we want to read in the metadata file so we can add that in too
# This is not a csv file, so we have to use a slightly different syntax
# here the `sep = "\t"` tells the function that the data are tab-delimited
# and the `stringsAsFactors = FALSE` tells it not to assume that things are
# categorical variables
metadata_in <- read.table(paste0("data/metadata/",
                                 "fierer_forensic_hand_mouse_SraRunTable.txt"),
                          sep = "\t",
                          header = TRUE,
                          stringsAsFactors = FALSE)

# Finally we use the left_join() function from dplyr to merge or 'join' the
# combined data and metadata into one big table, so it's easier to work with
# in R the `by = c("Run_s" = "sample_name")` syntax tells R which columns
# to match up when joining the datasets together
joined_blast_data_metadata <- metadata_in %>%
  left_join(joined_blast_data,
            by = c("Run_s" = "sample_name"))
```


```{r histograms}
# Here we're using the dplyr piping syntax to select a subset of rows matching a
# criteria we specify (using the filter) function, and then pull out a column
# from the data to make a histogram. We don't need to tell the hist() function
# which data to use, because that's piped in, but we do have to give the
# hist() function the title and axis label we'd like to use for the figure
joined_blast_data_metadata %>%
  filter(env_material_s == "sebum") %>%
  pull(pident) %>%
  hist(main = "Percent Identity",
       xlab = "Percent")
```

Fig. 1 Percent Identity of Microbial DNA from Human Sebum

Percent identity refers to a quantitative measurement of the similarity between two sequences (DNA, amino acid or otherwise). In figure 1, we see the range of similarity between all microbial DNA sequences detected in human sebum samples. The vast majority of the microbial DNA collected matched completely with another sequence collected from skin sebum secretions, occurring at a very high frequency of at least 2,500. The next largest percent similarity occurred at about 87% similarity with other sequences, and no sequences had percent identities that fell below 80%. 




```{r summary-table}
# Finally, we'd like to be able to make a summary table of the counts of
# sequences for each taxa for each sample. To do that we can use the table()
# function. We add the kable() function as well (from the tidyr package)
# in order to format the table nicely when the document is knitted
kable(table(joined_blast_data_metadata$sscinames,
            joined_blast_data_metadata$Run_s))
```

# Discussion

Add 2-3 paragraphs here interpreting your results and considering future directions one might take in analyzing these data.

